# Sign-In with Ethereum (SIWE) with wagmi

## Overview

Sign-In with Ethereum is an authentication standard (EIP-4361) that enables secure communication between a frontend and backend. SIWE allows web applications to create user sessions based on Ethereum wallet connections, providing a password-less, secure authentication method that gives users full control over their digital identity.

## How SIWE Works

The SIWE authentication flow consists of four main steps:

1. **Connect wallet** - User connects their Ethereum wallet to the application
2. **Sign message** - User signs a specially formatted SIWE message containing a nonce generated by the backend
3. **Verify signature** - Backend verifies the submitted message and signature
4. **Create session** - Backend adds validated SIWE data to a user session (via JWT, cookie, etc.)

The signed message proves ownership of the Ethereum address without revealing private keys, creating a secure authentication method.

## Key Benefits of SIWE

- **No passwords** - Users don't need to remember or store passwords
- **Security** - Private keys never leave the user's wallet
- **User control** - Users maintain full ownership of their digital identity
- **Seamless experience** - Works across web3 applications
- **Persistence** - Can maintain authentication state across page refreshes and sessions

## Implementation with wagmi

### Prerequisites

Required packages:

- `wagmi` - For wallet connection and message signing
- `siwe` - For creating and verifying SIWE messages
- Session management (e.g., `iron-session`, `next-auth`, etc.)

### Implementation Options Comparison: iron-session vs NextAuth.js

#### iron-session

**Pros:**

- Lightweight and focused solely on session management
- Stores encrypted session data directly in cookies ("seals")
- Stateless from the server perspective (no session IDs)
- More control over authentication flows
- Simpler implementation for specific use cases

**Cons:**

- Requires writing your own authentication logic
- Less out-of-the-box functionality than NextAuth.js
- No built-in social authentication providers

#### NextAuth.js

**Pros:**

- Complete authentication solution with multiple providers
- Built-in database adapters
- JWT or database session handling
- Built-in CSRF protection
- Callbacks for customizing token and session data
- More robust for complex authentication scenarios

**Cons:**

- More opinionated about how authentication should work
- Can be more complex to customize for specific use cases
- Might include features you don't need

### Implementation with iron-session

#### 1. Configure TypeScript (if using TypeScript)

Create types for your session data:

```typescript
// types/iron-session/index.d.ts
import 'iron-session'
import { SiweMessage } from 'siwe'

declare module 'iron-session' {
  interface IronSessionData {
    nonce?: string
    siwe?: SiweMessage
  }
}
```

#### 2. Create Backend API Routes

**Nonce Generation Route**:
Generate a random nonce for the user session to prevent replay attacks.

```typescript
// Example: pages/api/auth/nonce.ts (Next.js)
import { withIronSessionApiRoute } from 'iron-session/next'
import { NextApiRequest, NextApiResponse } from 'next'
import { generateNonce } from 'siwe'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'GET') {
    return res.status(405).end(`Method ${req.method} Not Allowed`)
  }

  req.session.nonce = generateNonce()
  await req.session.save()
  res.setHeader('Content-Type', 'text/plain')
  res.send(req.session.nonce)
}

export default withIronSessionApiRoute(handler, ironSessionOptions)
```

**Verification Route**:
Verify the SIWE message and signature to authenticate the user.

```typescript
// Example: pages/api/auth/verify.ts (Next.js)
import { withIronSessionApiRoute } from 'iron-session/next'
import { NextApiRequest, NextApiResponse } from 'next'
import { SiweMessage } from 'siwe'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    return res.status(405).end(`Method ${req.method} Not Allowed`)
  }

  try {
    const { message, signature } = req.body
    const siweMessage = new SiweMessage(message)
    const fields = await siweMessage.verify({ signature })

    if (fields.data.nonce !== req.session.nonce) {
      return res.status(422).json({ message: 'Invalid nonce.' })
    }

    req.session.siwe = fields
    await req.session.save()
    res.json({ ok: true })
  } catch (error) {
    res.json({ ok: false })
  }
}

export default withIronSessionApiRoute(handler, ironSessionOptions)
```

### Implementation with NextAuth.js in the Next.js App Router

For Next.js 13+ with the App Router, the implementation differs from previous versions. Here's how to set it up:

#### 1. Install Required Packages

```bash
npm install next-auth siwe wagmi @wagmi/core
```

#### 2. Create Auth Route with App Router

Create a file at `src/app/api/auth/[...nextauth]/route.ts`:

```typescript
import { AuthOptions } from 'next-auth'
import NextAuth from 'next-auth/next'
import CredentialsProvider from 'next-auth/providers/credentials'
import { getCsrfToken } from 'next-auth/react'
import { SiweMessage } from 'siwe'

export const authOptions: AuthOptions = {
  providers: [
    CredentialsProvider({
      id: 'siwe',
      name: 'Sign-In with Ethereum',
      credentials: {
        message: {
          label: 'Message',
          placeholder: '0x0',
          type: 'text',
        },
        signature: {
          label: 'Signature',
          placeholder: '0x0',
          type: 'text',
        },
      },
      async authorize(credentials, req) {
        try {
          const siwe = new SiweMessage(JSON.parse(credentials?.message || '{}'))

          // Get domain from environment or Vercel URL
          const nextAuthUrl =
            process.env.NEXTAUTH_URL ||
            (process.env.VERCEL_URL
              ? `https://${process.env.VERCEL_URL}`
              : null)

          if (!nextAuthUrl) {
            return null
          }

          const nextAuthHost = new URL(nextAuthUrl).host

          // Verify domain matches
          if (siwe.domain !== nextAuthHost) {
            return null
          }

          // Verify nonce
          if (
            siwe.nonce !==
            (await getCsrfToken({ req: { headers: req.headers } }))
          ) {
            return null
          }

          // Verify signature
          await siwe.verify({ signature: credentials?.signature || '' })

          // Return user data
          return {
            id: siwe.address,
          }
        } catch (e) {
          return null
        }
      },
    }),
  ],
  session: { strategy: 'jwt' },
  debug: process.env.NODE_ENV === 'development',
  secret: process.env.NEXTAUTH_SECRET,
  callbacks: {
    async session({ session, token }) {
      session.address = token.sub
      session.user = {
        name: token.sub,
      }
      return session
    },
  },
}

const handler = NextAuth(authOptions)
export { handler as GET, handler as POST }
```

#### 3. Create Auth Provider Components

Create a component to handle SIWE authentication:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { useAccount, useSignMessage, useNetwork } from 'wagmi';
import { SiweMessage } from 'siwe';
import { getCsrfToken, signIn, useSession, signOut } from 'next-auth/react';

export function SiweButton() {
  const { address, isConnected } = useAccount();
  const { chain } = useNetwork();
  const { signMessageAsync } = useSignMessage();
  const { data: session } = useSession();
  const [loading, setLoading] = useState(false);

  const handleSignIn = async () => {
    try {
      setLoading(true);

      // Get the CSRF token
      const csrfToken = await getCsrfToken();
      if (!csrfToken) throw new Error('CSRF token not found');

      // Create SIWE message
      const message = new SiweMessage({
        domain: window.location.host,
        address: address,
        statement: 'Sign in with Ethereum to the application.',
        uri: window.location.origin,
        version: '1',
        chainId: chain?.id,
        nonce: csrfToken,
      });

      // Sign the message
      const signature = await signMessageAsync({
        message: message.prepareMessage(),
      });

      // Verify with backend and create session
      await signIn('siwe', {
        message: JSON.stringify(message),
        signature,
        redirect: false,
      });
    } catch (error) {
      console.error('Error signing in:', error);
    } finally {
      setLoading(false);
    }
  };

  if (session && session.address) {
    return (
      <div>
        <p>Signed in as {session.address}</p>
        <button onClick={() => signOut()}>Sign Out</button>
      </div>
    );
  }

  if (isConnected && address) {
    return (
      <button
        onClick={handleSignIn}
        disabled={loading}
      >
        {loading ? 'Signing...' : 'Sign-In with Ethereum'}
      </button>
    );
  }

  return null;
}
```

## Best Practices

1. **Separate Connect and Sign Steps**: Keep wallet connection and message signing as separate steps, especially for WalletConnect on iOS to avoid deep linking issues.

2. **Pre-fetch Nonce**: Fetch the nonce when the sign-in component mounts to ensure it's ready when needed.

3. **Nonce Security**: Invalidate nonces after use to prevent replay attacks.

4. **Error Handling**: Implement robust error handling for all steps in the authentication flow.

5. **Session Expiry**: Set appropriate session expiry times and provide mechanisms for refreshing sessions.

6. **Domain Verification**: Ensure the domain in the SIWE message matches your application domain to prevent phishing attacks.

7. **Statement Clarity**: Use clear, user-friendly statements in your SIWE messages so users understand what they're signing.

## Comparison with Current Implementation

Our current implementation has several issues that could be improved by adopting the wagmi approach:

1. **CSRF Token Issues**: We're currently experiencing issues with CSRF token retrieval, which a proper SIWE implementation would resolve.

2. **Session Management**: The wagmi approach uses iron-session or NextAuth.js for more robust session management.

3. **User Experience**: The current flow has confusing steps; the wagmi approach provides a clearer user journey.

4. **Error Handling**: The wagmi example demonstrates more comprehensive error handling.

5. **Security**: The nonce-based approach in the wagmi example offers better protection against replay attacks.

## Recommended Implementation for Our Project

Based on our research, we recommend implementing SIWE with NextAuth.js in our Next.js application using the App Router. This approach provides several advantages:

1. **Built-in Security**: NextAuth.js handles CSRF protection, session management, and secure cookie handling.

2. **Seamless Integration**: The NextAuth.js API works well with both wagmi and our existing Next.js App Router structure.

3. **Flexibility**: We can easily extend the authentication system with additional providers if needed in the future.

4. **Better Error Handling**: The NextAuth.js callbacks provide more hooks for handling and displaying authentication errors.

5. **Community Support**: NextAuth.js has strong community support and is well-maintained.

The implementation will require:

1. Setting up NextAuth.js with a SIWE credentials provider
2. Creating a custom SIWE sign-in component using wagmi hooks
3. Properly handling the authentication state throughout the application

## Conclusion

Implementing Sign-In with Ethereum using wagmi provides a secure, user-friendly authentication system for web3 applications. The approach from the wagmi documentation offers a well-structured solution that addresses many common authentication challenges and provides a better user experience than our current implementation.

By following the steps outlined in this research document, we can improve our SIWE implementation to be more robust, secure, and user-friendly.

## References

- [wagmi SIWE Documentation](https://1.x.wagmi.sh/examples/sign-in-with-ethereum)
- [EIP-4361: Sign-In with Ethereum](https://eips.ethereum.org/EIPS/eip-4361)
- [SIWE Official Website](https://login.xyz/)
- [NextAuth.js Documentation](https://next-auth.js.org/)
- [iron-session Documentation](https://github.com/vvo/iron-session)
- [Example NextAuth.js App Router Implementation](https://github.com/AndonMitev/web3-nextjs-template)
